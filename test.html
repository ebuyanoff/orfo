<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Вопросы на грамотность</title>
  <meta name="description" content="Выберите правильный вариант или укажите, что затрудняетесь: тест определит ваши проблемные темы в русском языке.">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon.svg">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/test.css?v=3">
</head>
<body>

  <div id="testwrap">
    <div class="card">
      <div class="meta" id="meta"></div>

      <div class="sentence" id="sentence"></div>

      <div class="options" id="options" aria-label="Панель выбора">
        <button class="btn" id="left"  type="button"></button>
        <button class="btn" id="right" type="button"></button>
        <button class="btn mid" id="mid" type="button"><strong>честно не знаю</strong></button>
      </div>

      <div id="results" >

        <h2>Ваши результаты</h2>

        <p>Ниже идут темы и процент правильных ответов. Нажмите на строку, чтобы посмотреть памятку.</p>

        <div id="resultstabel"><!--тут будет таблица--></div>

        <p>Сохраните результат и получите памятку с правилами и примерами в telegram:</p>

        <ol>
          <li> Скопируйте код результата:
            <span id="copyresultid" tabindex="0" role="button" aria-label="Скопировать код результата"></span>.
          </li>
          <li> Отправьте код
            <a id="tgTextLink" href="https://t.me/evgenybuyanoff" target="_blank" class="disabled" aria-disabled="true">в телеграм</a>
            (не бот).
          </li>
        </ol>

        <div class="telegramwrap">
          <a id="tgBtn" class="btn btmtg disabled" href="https://t.me/evgenybuyanoff" target="_blank" aria-disabled="true">Получить в telegram</a>
        </div>

      </div>

    </div>
  </div>

  <div id="overlay" class="overlay" aria-hidden="true"></div>
  <aside id="rulepanel" class="rulepanel" aria-hidden="true">
    <button class="rulepanel__close" id="ruleclose" aria-label="Закрыть">×</button>
    <div class="rulepanel__inner" id="rulecontent"></div>
  </aside>

  <script src="js/topics.js?v=3"></script>
  <script src="js/texts.js?v=3"></script>

<script>
(() => {
  const $sentence = document.getElementById('sentence');
  const $meta = document.getElementById('meta');
  const $btnL = document.getElementById('left');
  const $btnR = document.getElementById('right');
  const $btnM = document.getElementById('mid');
  const $results = document.getElementById('results');
  const $resultstabel = document.getElementById('resultstabel');
  const $opts = document.getElementById('options');

  const $overlay = document.getElementById('overlay');
  const $rulePanel = document.getElementById('rulepanel');
  const $ruleClose = document.getElementById('ruleclose');
  const $ruleContent = document.getElementById('rulecontent');

  // ссылки/кнопки ТГ
  const $tgTextLink = document.getElementById('tgTextLink');
  const $tgBtn = document.getElementById('tgBtn');

  $results.style.display = 'none';

  // --- Плоский список гэпов на основе TEXTS (из внешнего файла) ---
  const gaps = [];
  window.TEXTS.forEach((t, ti) => {
    t.parts.forEach((p, pi) => {
      if (typeof p === 'object') {
        gaps.push({ textIndex: ti, partIndex: pi, ...p, user: null, ok: null, idk:false });
      }
    });
  });

  // Статистика по темам
  const stats = {};
  Object.keys(window.TOPICS).forEach(k => { stats[k] = { ok: 0, total: 0 }; });

  // Текущий активный гэп
  let gapCursor = 0;

  // «последний ответ в тексте» — ждём ручного Next
  let waitingNext = false;
  let waitingTextIndex = null;
  let queuedGapCursor = null;

  function findGapIndexByIds(textId, gapId) {
    return gaps.findIndex(g => window.TEXTS[g.textIndex].id === textId && g.id === gapId);
  }

  function activeTextIndex() {
    return waitingNext ? waitingTextIndex : (gaps[gapCursor]?.textIndex ?? window.TEXTS.length - 1);
  }

  function renderText() {
    const ti = activeTextIndex();
    const text = window.TEXTS[ti];

    $meta.style.display = 'flex';
    $meta.innerHTML = `<strong>${ti + 1}/${window.TEXTS.length}</strong>`;

    let html = '';
    text.parts.forEach((p) => {
      if (typeof p === 'string') {
        html += p;
      } else {
        const gIdx = findGapIndexByIds(text.id, p.id);
        const isActive = !waitingNext && gIdx === gapCursor;
        const answered = gaps[gIdx].user !== null;

        const cls = ['gap'];
        if (isActive) cls.push('active');
        if (answered) {
          cls.push('done');
          if (gaps[gIdx].idk) cls.push('idontknow');
          else cls.push(gaps[gIdx].ok ? 'correct' : 'wrong');
        }

        let shown = '?';
        if (answered) {
          shown = gaps[gIdx].user;
        }

        html += `<span class="nowrap">${p.pre}<span class="${cls.join(' ')}" data-topic="${p.topic}" data-text-id="${text.id}" data-gap-id="${p.id}">${shown}</span>${p.post}</span>`;
      }
    });

    $sentence.innerHTML = html;
    updateButtonsForActiveState();
  }

  function updateButtonsForActiveState() {
    if (waitingNext) {
      $btnR.textContent = 'Дальше';
      $btnR.classList.add('btn--wide');
      $btnR.style.display = '';
      $btnL.style.display = 'none';
      $btnM.style.display = 'none';
      return;
    }
    $btnR.classList.remove('btn--wide');
    $btnL.style.display = '';
    $btnR.style.display = '';
    $btnM.style.display = '';

    const g = gaps[gapCursor];
    if (!g) return;
    $btnL.textContent = g.btnLeft;
    $btnR.textContent = g.btnRight;
  }

function sendMetricPayload(g, choice, ok) {
  const payload = {
    textId: window.TEXTS[g.textIndex].id,
    gapId: g.id,
    topic: g.topic,
    topicTitle: window.TOPICS[g.topic]?.title || '',
    topicRuleUrl: window.TOPICS[g.topic]?.ruleUrl || '',   // ← НОВОЕ
    choice: choice,
    correct: g.correct,
    isCorrect: !!ok,
    timestamp: Date.now(),
    result_code: RESULT_CODE
  };
  fetch(new URL('answer.php', API_BASE), {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(payload)
  }).catch(()=>{});
}


  function answer(choice) {
    if (waitingNext) return;

    const g = gaps[gapCursor];
    if (!g) return;

    let actual = choice;
    if (choice === g.btnLeft) {
      actual = g.left;
    } else if (choice === g.btnRight) {
      actual = g.right;
    }

    const isIdk = choice === 'честно не знаю';
    if (isIdk) { g.idk = true; actual = g.correct; g.ok = null; }
    else { g.idk = false; g.ok = actual === g.correct; }
    g.user = actual;

    if (!isIdk) {
      stats[g.topic].total += 1;
      if (g.ok) stats[g.topic].ok += 1;
    }

    sendMetricPayload(g, choice, g.ok === true);

    const currentTextIndex = g.textIndex;

    const allInTextAnswered = gaps
      .filter(x => x.textIndex === currentTextIndex)
      .every(x => x.user !== null);

    if (allInTextAnswered) {
      waitingNext = true;
      waitingTextIndex = currentTextIndex;

      let nextIdx = gapCursor + 1;
      while (nextIdx < gaps.length && gaps[nextIdx].user !== null) nextIdx++;
      queuedGapCursor = nextIdx >= gaps.length ? gaps.length : nextIdx;

      renderText();
      return;
    }

    let nextIdx = gapCursor + 1;
    while (nextIdx < gaps.length && gaps[nextIdx].user !== null) nextIdx++;
    gapCursor = nextIdx;

    if (gapCursor >= gaps.length) {
      showResults();
    } else {
      renderText();
    }
  }

  function goNext() {
    if (!waitingNext) return;

    if (queuedGapCursor >= gaps.length) {
      showResults();
      return;
    }
    gapCursor = queuedGapCursor;
    waitingNext = false;
    waitingTextIndex = null;
    queuedGapCursor = null;

    renderText();
  }

  function showResults() {
    $sentence.innerHTML = '';
    $opts.style.display = 'none';
    $meta.style.display = 'none';

    const rows = Object.keys(stats).map(k => {
      const s = stats[k];
      const pct = s.total ? Math.round((s.ok / s.total) * 100) : 0;
      return { topic:+k, title: window.TOPICS[k].title, pct };
    }).sort((a,b) => a.pct - b.pct);

    const inner = rows.map(r => (
      `<div class="topicresult" data-topic="${r.topic}"><span>${r.title}</span> <span>${r.pct}%</span></div>`
    )).join('');

    $resultstabel.innerHTML = `${inner}`;
    $results.style.display = 'block';

    const restart = document.getElementById('restart');
    if (restart) restart.addEventListener('click', resetAll);
  }

  function resetAll() {
    for (const k in stats) { stats[k].ok = 0; stats[k].total = 0; }
    gaps.forEach(g => { g.user = null; g.ok = null; g.idk = false; });
    gapCursor = 0;
    waitingNext = false;
    waitingTextIndex = null;
    queuedGapCursor = null;

    $opts.style.display = 'grid';
    $results.style.display = 'none';
    renderText();
  }

  // Правила
  function openRule(topic) {
    const rule = window.TOPICS[topic];
    if (!rule) return;
    const inner = rule.ruleHtml && rule.ruleHtml.trim()
      ? rule.ruleHtml
      : `<h2>${rule.title}</h2>`;
    $ruleContent.innerHTML = inner;
    $overlay.classList.add('open');
    $overlay.setAttribute('aria-hidden','false');
    $rulePanel.classList.add('open');
    $rulePanel.setAttribute('aria-hidden','false');
  }
  function closeRule() {
    $rulePanel.classList.remove('open');
    $rulePanel.setAttribute('aria-hidden','true');
    $overlay.classList.remove('open');
    $overlay.setAttribute('aria-hidden','true');
  }
  $ruleClose.addEventListener('click', closeRule);
  $overlay.addEventListener('click', closeRule);
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeRule(); });

  // Клик по гэпу — правило
  $sentence.addEventListener('click', (e) => {
    const el = e.target.closest('.gap.done');
    if (!el) return;
    const topic = +el.dataset.topic;
    openRule(topic);
  });
  // Клик по теме — правило
  $results.addEventListener('click', (e) => {
    const row = e.target.closest('.topicresult');
    if (!row) return;
    const topic = +row.dataset.topic;
    openRule(topic);
  });

  // Кнопки 
  $btnL.addEventListener('click', () => { if (!waitingNext) answer($btnL.textContent); });
  $btnR.addEventListener('click', () => { if (waitingNext) goNext(); else answer($btnR.textContent); });
  $btnM.addEventListener('click', () => { if (!waitingNext) answer('честно не знаю'); });

  // Клавиатура
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') {
      if (!waitingNext) { pulse($btnL); answer($btnL.textContent); }
    } else if (e.key === 'ArrowRight') {
      pulse($btnR);
      if (waitingNext) goNext();
      else answer($btnR.textContent);
    } else if (e.key === 'ArrowDown') {
      if (!waitingNext) { pulse($btnM); answer('честно не знаю'); }
    }
  });

  function pulse(btn) {
    btn.classList.add('is-pressed');
    setTimeout(() => btn.classList.remove('is-pressed'), 120);
  }

  // === Глобальная защита: disabled → alert и отмена перехода ===
  const disabledGuard = (e) => {
    const target = e.target.closest('a.disabled, button.disabled, .btn.disabled');
    if (target) {
      e.preventDefault();
      e.stopPropagation();
      alert('Сначала скопируйте код результата.');
    }
  };
  document.addEventListener('click', disabledGuard, true);
  document.addEventListener('keydown', (e) => {
    if ((e.key === 'Enter' || e.key === ' ') &&
        e.target && e.target.closest && e.target.closest('a.disabled, button.disabled, .btn.disabled')) {
      e.preventDefault();
      alert('Сначала скопируйте код результата.');
    }
  }, true);

// === Скопировать результат ===
(() => {
  const el = document.getElementById('copyresultid');
  if (!el) return;

  let originalText = '';   // запомним код
  let locked = false;      // блокировка на время "скопировано"

  function copyAction() {
    if (locked) return; // нельзя повторно кликнуть пока "скопировано"

    const text = el.textContent.trim();
    if (!text) return;

    originalText = text;

    navigator.clipboard.writeText(text).then(() => {
      showCopied();
      unlockTelegram();
    }).catch(() => {
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try { document.execCommand('copy'); } catch(e) {}
      document.body.removeChild(ta);
      showCopied();
      unlockTelegram();
    });
  }

  function showCopied() {
    locked = true;
    el.textContent = 'скопировано';
    el.style.pointerEvents = 'none';
    setTimeout(() => {
      el.textContent = originalText;
      el.style.pointerEvents = '';
      locked = false;
    }, 900);
  }

  function unlockTelegram() {
    [document.getElementById('tgTextLink'),
     document.getElementById('tgBtn')].forEach((node) => {
      if (!node) return;
      node.classList.remove('disabled');
      node.removeAttribute('aria-disabled');
    });
  }

  el.addEventListener('click', copyAction);
  el.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter' || ev.key === ' ') {
      ev.preventDefault();
      copyAction();
    }
  });
})();


  // Старт
  renderText();
})();
</script>

  <script src="js/test.js?v=3"></script>
</body>
</html>
